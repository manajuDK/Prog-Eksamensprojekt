@page "/gamepage"
@using Blazor_Poker_Nights


<h3>GamePage</h3>
@if (activePlayer is not null)
{
	<UserGameInfo player=activePlayer @ref="activeComp"></UserGameInfo>
	<p>Current bet this round: @roundBet DKK; Current gold in pot: @pot DKK</p>
	<div class="options">
		<button @onclick="check">@(activePlayer.currentBet == roundBet ? "Check" : "Call")</button>
		<div>
			<button @onclick="raise">Raise</button> <input type="text" placeholder="bet amount..." @bind="betAmount" />
		</div>

		<button @onclick="fold">Fold</button>
	</div>
	
			<div id="userInfo">
			<svg width="1200"
				 height="130"
				 xmlns="http://www.w3.org/2000/svg"
				 xmlns:xlink="http://www.w3.org/1999/xlink">
				@for (int z = 0; z < (turn != 0 ? turn + 2 : 0); z++)
				{
					<use href="@table[z].getName()" x="@(z*190)" y="10"
						 transform="rotate(0)scale(0.5)" />
				}

			</svg>
			</div>
	

	@foreach (User player in players)
	{
		if (!player.active)
		{
			<div class="scores">
				<UserGameInfo player=player></UserGameInfo>
			</div>
			
		}
		
	}

	<button @onclick="changeActive">Change turn</button>

}
<style>
	div.scores {
		width: 20%;
		float: left;
		margin: 5px;
	}
	.option{
		width: 50%;
		float: center;
		margin: 5px;
	}
</style>


@code {

	Deck deck;
	List<User> players = new List<User>();
	User activePlayer;
	Card[] table = new Card[5];
	int turn = 0;
	int roundBet = 0;
	int pot = 0;
	UserGameInfo activeComp;
	User roundEndAt; //the round ends when this user gets his turn again
	int betAmount = 0;

	public void check()
	{
		if (activePlayer.currentBet != roundBet)
		{
			int diff = roundBet - activePlayer.currentBet;
			activePlayer.bet(diff);
			pot += diff;
			activePlayer.currentBet = roundBet;	
		}
		else if (activePlayer.name == roundEndAt.name) // doesnt work if roundEndAt spilleren folder
		{
			newTurn();
		}
		changeActive();
	}

	public void newTurn()
	{
		turn++;
		roundBet = 0;
		betAmount = 0;
		int id = (Shared.GlobalInfo.rounds + (Shared.GlobalInfo.userList.Count - 1)) % Shared.GlobalInfo.userList.Count;
		roundEndAt = Shared.GlobalInfo.userList[id];
	}

	public void fold()
	{
		players.Remove(activePlayer);
		changeActive();
	}

	public void raise()
	{
		if (betAmount > 0){
			roundBet += betAmount;
			int diff = roundBet - activePlayer.currentBet;
			activePlayer.bet(diff);
			pot += diff;
			activePlayer.currentBet = roundBet;
			betAmount = 0;
			changeActive();
		}
	}

	public void changeActive()
	{
		if (activePlayer is not null)
		{
			activePlayer.active = false;
		}

		Console.WriteLine("player 1 " + players[0].name + " player 2 " + players[players.Count - 1].name);

		players[players.Count - 1].active = true;
		User[] turnOrderChange = new User[players.Count];

		for (int i = 0; i < players.Count; i++) // shuffle
		{
			turnOrderChange[(i + 1) % players.Count] = players[i];
		}
		players = turnOrderChange.ToList<User>();

		activePlayer = players[0];
		//Console.WriteLine("Acgive: " + activePlayer.name);
		activePlayer.active = true;
		if (activeComp.showCards)
		{
			activeComp.show();
		}
	}


	protected override async Task OnInitializedAsync()
	{
		deck = new Deck();

		for (int i = 0; i < 5; i++)
		{
			table[i] = deck.draw();
		}

		for (int i = 0; i < Shared.GlobalInfo.userList.Count; i++){
			int id = (Shared.GlobalInfo.rounds + i) % Shared.GlobalInfo.userList.Count;
			players.Add(Shared.GlobalInfo.userList[id]);
		}

		foreach (User player in players)
		{
			player.hand[0] = deck.draw();
			player.hand[1] = deck.draw();
		}
		players[0].active = true;
		activePlayer = players[0];
		newTurn();
	}
	private int CardValue(int value)
	{
		if (value == 1)
		{
			return 14;
		} else
		{
			return value;
		}
	}
	private int[] FindHand(User player)
	{
		int[] playerVals = new int[2]; /*[0] is type of hand, 1 is High Card, 2 is Pair, 3 is Two Pair, 4 is Three of a kind, 
		5 is Straight, 6 is Flush, 7 is Full House, 8 is Four of a Kind, 9 is Straight Flush, 10 is Royal Flush,
		[1] is value of highest card*/
		int[] values = new int[7];
		string[] suits = new string[7];
		for (int n = 0; n < 7; n++)
		{
			if (n < 2)
			{
				values[n] = player.hand[n].value;
				suits[n] = player.hand[n].suit;
			} else
			{
				values[n] = table[n - 2].value;
				suits[n] = table[n - 2].suit;
			}
		}
		//High card
		playerVals[0] = 1;
		playerVals[1] = values.Max();
		//Pair, Two Pair, Three of a Kind, Full House, Four of a Kind
		var query = values.GroupBy(x => x, (value, all) => new
		{
			Key = value,
			Count = all.Count(),
		});
		foreach (var result in query)
		{
			if (result.Count == 2)
			{
				//Check for Two Pair
				if (playerVals[0] == 2)
				{
					playerVals[0] = 3;
					if (playerVals[0] < CardValue(result.Key))
					{
						playerVals[1] = CardValue(result.Key);
					}
				} //Check for Full House (Three of a Kind with Pair found)
				else if (playerVals[0] == 4)
				{
					playerVals[0] = 7;
				} else
				{
					playerVals[0] = 2;
					playerVals[1] = CardValue(result.Key);
				}
			} //Check for Three of a Kind
			else if (result.Count == 3)
			{
				//Check for Full House (Pair with Three of a kind found)
				if (playerVals[0] == 2)
				{
					playerVals[0] = 7;
					playerVals[1] = CardValue(result.Key);
				} else
				{
					playerVals[0] = 4;
					playerVals[1] = CardValue(result.Key);
				}
			} //Check for Four of a Kind
			else if (result.Count == 4)
			{
				playerVals[0] = 8;
				playerVals[1] = CardValue(result.Key);
			}
		}
		//Check for Flush
		if (suits.Distinct().Count() == 1)
		{
			playerVals[0] = 6;
			playerVals[1] = values.Max();
		}
		//Straight, Straight Flush, Royal Flush
		int[] sortedValues = values.OrderByDescending(x => x).ToArray();
		int straightCount = 0;
		for (int n = 1; n < 7; n++)
		{
			if (sortedValues[n - 1] - 1 == sortedValues[n])
			{
				straightCount++;
				//Check for Straight
				if (straightCount == 4)
				{
					//Check for Straight Flush
					if (playerVals[0] == 6)
					{
						//Check for Royal Flush
						if (CardValue(sortedValues[n - 4]) == 14)
						{
							playerVals[0] = 10;
						} else
						{
							playerVals[0] = 9;
							playerVals[1] = CardValue(sortedValues[n - 4]);
						}
					} else
					{
						playerVals[0] = 5;
						playerVals[1] = CardValue(sortedValues[n - 4]);
					}
				}
			} else
			{
				straightCount = 0;
			}
		}
		return playerVals;
	}
}
